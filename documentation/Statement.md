## Спроектировать сервис уведомлений

Повторим, какие возможные компоненты есть в системе нотификации:
1. [x] База, в которой хранятся уведомления notification_id и content_id.
2. [x] API для приёма событий по созданию уведомлений (а может стоит через него управлять и уведомлениями в базе?):
  - [x] API процесс;
3. [x] Процесс, который отправляет уведомление (воркер):
  - [ ] База, в которой хранится история отправки уведомлений
4. [ ] Генератор автоматических событий:
  - [ ] шедулер;
  - [ ] cron;
  - [ ] база, в которой хранится периодичность уведомлений (а лучше бы это была одна база с п. 1).
5. [x] Админ-панель.
6. [ ] Реализуйте в своём сервисе модуль, отвечающий за генерацию и отправку персонализированных писем.
7. [ ] Опционально. Реализуйте модуль для работы с Websoket.
8. [ ] Сервис для сокращения ссылок
9. [ ] Реализуйте рассылку welcome-писем пользователям после регистрации в онлайн-кинотеатре.


## Подготовка данных для отправки уведомлений

1. [ ] Использовать вариант — гибридный.

2. [ ] Спроектируйте и распишите гибридный формат работы API, воркера, генератора автоматических уведомлений и админ-панели для трёх сценариев:
  - [ ] Любая часть сайта просит отправить мгновенное уведомление.
  - [ ] Генератор автоматических событий сгенерировал событие или события на большую группу пользователей.
  - [ ] Админ-панель, в которой менеджеры вручную создали рассылку уведомлений пользователям.


## Требования к итоговой архитектуре

1. [x] Для простоты можно рассылать только email-письма, но система должна иметь возможность расширения на другие типы уведомлений: смс, push и другие варианты.
2. [ ] Мгновенные уведомления должны отправляться с максимальной задержкой в несколько минут.
3. [ ] В случае падения любого компонента ничего не должно потеряться и любое уведомление должно быть получено клиентом.
4. [ ] В случае простоя генератора автоматических уведомлений (или аналогичного компонента) после его запуска не должны дублироваться старые и новые события.
5. [x] Должна быть возможность настройки уведомлений пользователем, в том числе отключение уведомлений.
6. [x] Должна быть единая система шаблонизации email-писем как для автоматических уведомлений, так и для рассылок, созданных менеджером .
7. [x] У системы должна быть возможность масштабироваться.


## Рекламная рассылка

8. [ ] Каждому пользователю необходимо отправить письмо с информацией и данными. Технически требуется загрузить все письма в очередь на рассылку и полностью обработать её.

Пропишем чек-лист, чтобы ничего не забыть:
- [ ] Персонифицировать каждое письмо. Для этого создайте шаблон письма с подставляемыми данными, который будет обогащаться данными пользователя перед отправкой.
- [ ] При обогащении данными предусмотреть возможное влияние пиковой нагрузки на распределённую систему. Одновременная обработка большого количества данных не должна приводить, например, к отказу подсистемы данных о пользователях при большом количестве одновременных запросов за данными.
  - [ ] Подсказка: регулировать нагрузку можно количеством одновременных запущенных консьюмеров. Также можно управлять скоростью работы каждого отдельного консьюмера при помощи таймаутов (sleep).
  - [ ] Ещё подсказка: снизить аффект на распределённую систему можно выделением специализированных slave-нод с данными только под чтение операции. Master-сервер при этом продолжит обслуживать клиентов в штатном режиме. Этот способ поможет распределить нагрузку, однако он дороже, сложнее в реализации и имеет свои особенности. Например, отставание slave-ноды от master: так вы рискуете отправить устаревшие данные.
- [ ] Предусмотреть failover-стратегию. Одна из подсистем всё-таки отказала. Что будет происходить с запущенной рассылкой? Как восстановить упавшую подсистему? Как снизить нагрузку на подсистему сразу после её восстановления?
  - [ ] Подсказка: при отказе одной из подсистем нужно иметь возможность мгновенно отключить любые запросы на неё. Это можно сделать, например, остановив все консьюмеры подготовки или отправки писем. После восстановления нужно отрегулировать входящую нагрузку на подсистему, чтобы не получилось повторного отказа. Опять же это можно сделать регулировкой количества одновременно запущенных консьюмеров и скоростью работы каждого консьюмера.
- [ ] При загрузке большого количества писем в очередь предусмотреть возможность снижения пикового RPS на запись. Это нужно для снижения аффекта на другие очереди этого сервера.
  - [ ] Подсказка: в процессе считывания данных из БД и публикации сообщений в очередь RabbitMQ на обработку, предусмотрите возможность искусственного занижения скорости публикации. Это можно сделать, встроив в цикл операцию sleep. Если пиковый RPS на запись начнёт аффектить другие очереди на том же сервере, нужно понизить скорость отправки сообщений в шину, увеличив параметр sleep.
- [ ] Предусмотреть в консьюмерах обработку ситуации с временными ошибками внешних сервисов. Они не должны приводить к потере конкретного сообщения.
  - [ ] Подсказка: иногда при потоковой обработке большого объёма данных могут «выстреливать» временные ошибки, например, флап базы данных или сети. В таких ситуациях обычно консьюмеры начинают ределиверить — пытаться снова и снова обработать сообщение и тем самым останавливают обработку всей очереди. Для таких ситуаций научите консьюмеров деградировать — отправлять проблемное сообщение во временную очередь, чтобы через некоторое время вернуться к его обработке. В RabbitMQ это делается через Dead Letter Queue.
- [ ] Убедиться, что обработка каждого сообщения идемпотентна. То есть повторная обработка того же самого сообщения не приводит к повторной отправке письма.


## CI

Помимо основного кода от вас требуется добавить CI пайплайн в Github Actions, который содержит следующие элементы:
1. [x] Проверка кода линтером wemake-python-styleguide.
2. [x] Проверка типов методов и переменных через mypy.
3. [x] Запуск кода на версиях Python 3.8 и 3.9.
4. [x] Отчёт по проверке линтерами в формате HTML-файла.
5. [ ] Сам CI/CD-процесс должен отправлять уведомление об успешности или неуспешности прохождения пайплайна в телеграм канал или группу. Само сообщение должно быть примерно такого вида:
```yaml
{project name}: Pipeline for {commit_hash} finished {"with error"|"successfully"}!
{if error}
{name of step} failed
{endif}
```
  Шаблон создан с помощью псевдокода. Если кратко, то сделать нужно следующее:
  - [ ] Указывать название репозитория в github (project name).
  - [ ] Добавить commit hash вашего коммита.
  - [ ] При успехе отдавать слово successfully, а при ошибке — with error.
  - [ ] Если произошла ошибка, то нужно выводить название шага, на котором она произошла.
6. [x] Ещё пара важных моментов:
  - [x] Не забудьте ограничить выполнение CI только с помощью pull request в мастер-ветку.
  - [x] В самом репозитории уберите возможность делать пуш в мастер.


## Общее описание работы сервиса

В API приходит запрос на уведомление, апи запаковывает в стандартный формат и ставит в очередь на обработку. Хэндлер забирает и в зависимости от срочности либо передаёт в очередь генератору, либо пишет в базу для планировщика. Планировщик просыпается по расписанию смотрит какие уведомления есть на рассылку. Ставит их в очередь генератору. Генератор берёт уведомление из очереди смотрит - например это массовое уведомление - он запрашивает в базе всех пользователей по данному уведомлению с фильтром у кого в настройках стоит разрешение на рассылку, сформированный список с необходимыми данными ставит в очередь воркеру. Воркер из списка по шаблону оформляет письма и ставит их в очередь на отправку и пишет в историю, откуда они уже рассылаются почтовым сервисом.


## Схемы передаваемых данных в очередях

### Notifications и Generator Queue

В очередь оповещений поступают объекты оповещений из API, в соответствии со следующей схемой:

```jsonc
{
  // Все опощещения должны иметь поле с метаинформацией необходимой для понимания сервисов
  // что делать с оповещением и куда направлять далее
  "meta": {
    "urgency": "immidiate|usual",  // Срочность оповещения: срочно|обычно
    "scale": "bulk|individual",  // Массовость оповещения: массовое|индивидуальное
    "email": "email@host.com",  // Для индивидуальных писем необходимо указать email
    "periodic": "true|false"  // Переодическое: да|нет
  },

  // Тип письма, влияет на то какие данные запросит генератор
  // и какой шаблон применит worker
  "type": "show_subs|info|welcome",

  // Опциональный параметр если нужно указать кастомный шаблон для данной рассылки
  "costom_template": "template_name",

  // Набор стандартных полей для шаблона
  // Если это массовая рассылка, то дополнительные данные будут получены генератором
  // в соответствии с типом шаблона
  "fields": [
    "login": "hello",
    "name": "Василий",
    "surname": "Сидоров",
    ...
  ]
}
```


### Worker Queue

```jsonc
{
  // Адрес, куда отправить письмо
  "email": "email@host.com",

  // Шаблон для данной письма
  "template": "template_name",

  // Набор стандартных полей для шаблона
  "fields": [
    "login": "hello",
    "name": "Василий",
    "surname": "Сидоров",
    ...
  ]
}
```


### Email Queue


```jsonc
{
  "email": "email@host.com",
  "content": "..."
}
```


## Шаблоны писем

Шаблоны писем используют синтаксис [jinja](https://jinja.palletsprojects.com/)


### Приветственные письма после регистрации пользователя

```html
<!DOCTYPE html>
<html lang="ru">
<head><title>Добро пожаловать!</title></head>
<body>
  <h1>Привет {{ name }}!</h1>
  <p>Рады приветствовать тебя в нашем кинотеатре!</p>
</body>
</html>
```


### Информационное письмо

```html
<!DOCTYPE html>
<html lang="ru">
<head><title>Для информации.</title></head>
<body>
  <h1>{{ title }}</h1>
  <p>{{ text }}</p>
</body>
</html>
```
