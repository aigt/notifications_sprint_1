# Чек лист с требованиями

Для отметки учтённых требовний

## Спроектировать сервис уведомлений

Повторим, какие возможные компоненты есть в системе нотификации:
1. [x] База, в которой хранятся уведомления notification_id и content_id.
2. [x] API для приёма событий по созданию уведомлений (а может стоит через него управлять и уведомлениями в базе?):
  - [x] API процесс;
3. [x] Процесс, который отправляет уведомление (воркер):
  - [x] База, в которой хранится история отправки уведомлений
4. [x] Генератор автоматических событий:
  - [x] шедулер;
  - [x] cron;
  - [x] база, в которой хранится периодичность уведомлений (а лучше бы это была одна база с п. 1).
5. [x] Админ-панель.
6. [x] Реализуйте в своём сервисе модуль, отвечающий за генерацию и отправку персонализированных писем.
7. [ ] Опционально. Реализуйте модуль для работы с Websoket.
8. [ ] Сервис для сокращения ссылок
9. [x] Реализуйте рассылку welcome-писем пользователям после регистрации в онлайн-кинотеатре.


## Подготовка данных для отправки уведомлений

1. [x] Использовать вариант — гибридный.

2. [x] Спроектируйте и распишите гибридный формат работы API, воркера, генератора автоматических уведомлений и админ-панели для трёх сценариев:
  - [x] Любая часть сайта просит отправить мгновенное уведомление.
  - [x] Генератор автоматических событий сгенерировал событие или события на большую группу пользователей.
  - [x] Админ-панель, в которой менеджеры вручную создали рассылку уведомлений пользователям.


## Требования к итоговой архитектуре

1. [x] Для простоты можно рассылать только email-письма, но система должна иметь возможность расширения на другие типы уведомлений: смс, push и другие варианты.
2. [x] Мгновенные уведомления должны отправляться с максимальной задержкой в несколько минут.
3. [x] В случае падения любого компонента ничего не должно потеряться и любое уведомление должно быть получено клиентом.
4. [x] В случае простоя генератора автоматических уведомлений (или аналогичного компонента) после его запуска не должны дублироваться старые и новые события.
5. [x] Должна быть возможность настройки уведомлений пользователем, в том числе отключение уведомлений.
6. [x] Должна быть единая система шаблонизации email-писем как для автоматических уведомлений, так и для рассылок, созданных менеджером .
7. [x] У системы должна быть возможность масштабироваться.


## Рекламная рассылка

8. [x] Каждому пользователю необходимо отправить письмо с информацией и данными. Технически требуется загрузить все письма в очередь на рассылку и полностью обработать её.

Пропишем чек-лист, чтобы ничего не забыть:
- [x] Персонифицировать каждое письмо. Для этого создайте шаблон письма с подставляемыми данными, который будет обогащаться данными пользователя перед отправкой.
- [x] При обогащении данными предусмотреть возможное влияние пиковой нагрузки на распределённую систему. Одновременная обработка большого количества данных не должна приводить, например, к отказу подсистемы данных о пользователях при большом количестве одновременных запросов за данными.
  - [x] Подсказка: регулировать нагрузку можно количеством одновременных запущенных консьюмеров. Также можно управлять скоростью работы каждого отдельного консьюмера при помощи таймаутов (sleep).
  - [x] Ещё подсказка: снизить аффект на распределённую систему можно выделением специализированных slave-нод с данными только под чтение операции. Master-сервер при этом продолжит обслуживать клиентов в штатном режиме. Этот способ поможет распределить нагрузку, однако он дороже, сложнее в реализации и имеет свои особенности. Например, отставание slave-ноды от master: так вы рискуете отправить устаревшие данные.
- [x] Предусмотреть failover-стратегию. Одна из подсистем всё-таки отказала. Что будет происходить с запущенной рассылкой? Как восстановить упавшую подсистему? Как снизить нагрузку на подсистему сразу после её восстановления?
  - [x] Подсказка: при отказе одной из подсистем нужно иметь возможность мгновенно отключить любые запросы на неё. Это можно сделать, например, остановив все консьюмеры подготовки или отправки писем. После восстановления нужно отрегулировать входящую нагрузку на подсистему, чтобы не получилось повторного отказа. Опять же это можно сделать регулировкой количества одновременно запущенных консьюмеров и скоростью работы каждого консьюмера.
- [x] При загрузке большого количества писем в очередь предусмотреть возможность снижения пикового RPS на запись. Это нужно для снижения аффекта на другие очереди этого сервера.
  - [ ] Подсказка: в процессе считывания данных из БД и публикации сообщений в очередь RabbitMQ на обработку, предусмотрите возможность искусственного занижения скорости публикации. Это можно сделать, встроив в цикл операцию sleep. Если пиковый RPS на запись начнёт аффектить другие очереди на том же сервере, нужно понизить скорость отправки сообщений в шину, увеличив параметр sleep.
- [ ] Предусмотреть в консьюмерах обработку ситуации с временными ошибками внешних сервисов. Они не должны приводить к потере конкретного сообщения.
  - [ ] Подсказка: иногда при потоковой обработке большого объёма данных могут «выстреливать» временные ошибки, например, флап базы данных или сети. В таких ситуациях обычно консьюмеры начинают ределиверить — пытаться снова и снова обработать сообщение и тем самым останавливают обработку всей очереди. Для таких ситуаций научите консьюмеров деградировать — отправлять проблемное сообщение во временную очередь, чтобы через некоторое время вернуться к его обработке. В RabbitMQ это делается через Dead Letter Queue.
- [ ] Убедиться, что обработка каждого сообщения идемпотентна. То есть повторная обработка того же самого сообщения не приводит к повторной отправке письма.


## CI

Помимо основного кода от вас требуется добавить CI пайплайн в Github Actions, который содержит следующие элементы:
1. [x] Проверка кода линтером wemake-python-styleguide.
2. [x] Проверка типов методов и переменных через mypy.
3. [x] Запуск кода на версиях Python 3.8 и 3.9.
4. [x] Отчёт по проверке линтерами в формате HTML-файла.
5. [ ] Сам CI/CD-процесс должен отправлять уведомление об успешности или неуспешности прохождения пайплайна в телеграм канал или группу. Само сообщение должно быть примерно такого вида:
```yaml
{project name}: Pipeline for {commit_hash} finished {"with error"|"successfully"}!
{if error}
{name of step} failed
{endif}
```
  Шаблон создан с помощью псевдокода. Если кратко, то сделать нужно следующее:
  - [ ] Указывать название репозитория в github (project name).
  - [ ] Добавить commit hash вашего коммита.
  - [ ] При успехе отдавать слово successfully, а при ошибке — with error.
  - [ ] Если произошла ошибка, то нужно выводить название шага, на котором она произошла.
6. [x] Ещё пара важных моментов:
  - [x] Не забудьте ограничить выполнение CI только с помощью pull request в мастер-ветку.
  - [x] В самом репозитории уберите возможность делать пуш в мастер.


Логика работы с таймзонами

Почтовый сервис (sengrid, Amazon SES и птп)



Механики

Вышла новая серия
Ваш комментарий лайкнули
реклама кинонавинок
Напоминание про отложенные фильмы
Персональная рассылка из админпанели
